[TOC]



# 简介

MySQL数据库，关系型数据库。

- **原子性(Atomicity)**：原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

- **一致性(Consistency)**：一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。*假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性*。

- **隔离性(Isolation)**：隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

- **持久性(Durability)**：持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。



# 索引

MySQL采用B+树来存储索引。

MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。

虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。InnoDB的数据文件本身就是索引文件。



**物理存储的角度**：

> **聚簇索引默认是主键**，如果表中没有定义主键，InnoDB 会选择一个**唯一的非空索引**代替。如果没有这样的索引，InnoDB 会**隐式定义一个主键**来作为聚簇索引。InnoDB 只聚集在同一个页面中的记录。包含相邻键值的页面可能相距甚远。**如果你已经设置了主键为聚簇索引，必须先删除主键，然后添加我们想要的聚簇索引，最后恢复设置主键即可**。

- 聚簇索引（InnoDB里唯一）：将数据存储与索引放到一起，找到同时也找到了数据。
- 非聚簇索引：数据与索引分开存放，找到后还需要查询一次数据。

**逻辑角度**：

- 主键索引：特殊的唯一索引，不允许有空值。一般建表的同时创建主键索引。
- 普通索引：没有任何限制。
- 唯一索引：索引列表必须唯一，允许有空值。
- 复合索引：多个字段一起建立索引。



## 创建索引的好处

1. 通过创建索引，可以在查询的过程中，提高系统的性能
2. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一
3. 在使用分组和排序子句进行数据检索时，可以减少查询中分组和排序的时间

## 创建索引的坏处

1. 创建索引和维护索引要耗费时间，而且时间随着数据量的增加而增大。
2. 索引需要占用物理空间，如果要建立聚簇索引，所需要的空间会更大。
3. 在对表中的数据进行增加删除和修改时需要耗费较多的时间，因为索引也要动态地维护。

## 应该在哪些列上创建索引呢

1. 经常需要搜索的列上
2. 作为主键的列上
3. 经常用在连接的列上，这些列主要是一些外键,可以加快连接的速度
4. 经常需要根据范围进行搜索的列上
5. 经常需要排序的列上
6. 经常使用在where子句上面的列上

## 不应该在哪些列上创建索引

1. 查询中很少用到的列
2. 对于那些具有很少数据值的列.比如人事表的性别列,bit数据类型的列
3. 对于那些定义为text,image的列.因为这些列的数据量相当大
4. 当对修改性能的要求远远大于搜索性能时.因为当增加索引时,会提高搜索性能,但是会降低修改性能

## 数据库索引在什么情况下失效

1. **联合索引不满足最左匹配原则**：联合索引遵从最左匹配原则，顾名思义，在联合索引中，最左侧的字段优先匹配。因此，在创建联合索引时，where子句中使用最频繁的字段放在组合索引的最左侧。即**最左边的字段要出现在查询条件中**。数据库本身会对where做优化，所以不必太担心顺序问题。

2. **使用了`select *`**。这种情况联合索引无法生效。

3. **索引列参与运算**，如：

   ```mysql
   explain select * from t_user where id + 1 = 2 ;
   ```

4. **索引列参使用了函数**，基本类同第三条。

5. **`Like`使用的时候没有匹配前缀**。例如：`%abc%`与`abc%`。第二个可以走索引，但是第一个不行。

6. **索引类型隐式转换**。例如一个字段是`varchar`，在`where`里和整形比较了。

7. **使用`or`**。这种情况必须两个字段都要索引，否则索引失效。

8. **Mysql优化器优化**，在某些时候它认为全表扫描比索引更快。



# 同步

## 锁

按照使用方式：

- **乐观锁**
- **悲观锁**

按照粒度：

> InnoDB行锁和表锁都支持、MyISAM只支持表锁！
>
> InnoDB只有通过索引条件检索数据才使用行级锁，否则，InnoDB使用表锁也就是说，InnoDB的行锁是基于索引的！

- **表锁**：开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低。
  - 表共享锁
  - 表独占锁
- **行锁**：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高 不同的存储引擎支持的锁粒度是不一样的。
  - 共享锁
  - 排它锁
- **页锁**

> 如果某个进程想要获取读锁，同时另外一个进程想要获取写锁。在mysql中，写锁是优先于读锁的！
>
> 写锁和读锁优先级的问题是可以通过参数调节的：max_write_lock_count和low-priority-updates

### 行锁

InnoDB和MyISAM有**两个本质的区别**：InnoDB支持行锁、InnoDB支持事务。

InnoDB实现了以下两种类型的行锁：

- **共享锁（S锁、读锁）：** 允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。即多个客户可以同时读取同一个资源，但不允许其他客户修改。
- **排他锁（X锁、写锁)：** 允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的读锁和写锁。写锁是排他的，写锁会阻塞其他的写锁和读锁。

另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁：

- **意向共享锁（IS）：** 事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。
- **意向排他锁（IX）：** 事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。
- 意向锁也是数据库隐式帮我们做了，不需要程序员关心！



### MVCC行级锁

MVCC(Multi-Version ConcurrencyControl)多版本并发控制，可以简单地认为：MVCC就是行级锁的一个变种(升级版)。

在表锁中我们读写是阻塞的，基于提升并发性能的考虑，MVCC一般读写是不阻塞的(很多情况下避免了加锁的操作)。

可以简单的理解为：对数据库的任何修改的提交都不会直接覆盖之前的数据，而是产生一个新的版本与老版本共存，使得读取时可以完全不加锁。



### 乐观锁和悲观锁

我们使用**悲观锁**的话其实很简单(手动加行锁就行了)：select * from xxxx for update，在select 语句后边加了for update相当于加了排它锁(写锁)，加了写锁以后，其他事务就不能对它修改了！需要等待当前事务修改完之后才可以修改.也就是说，如果操作1使用select ... for update，操作2就无法对该条记录修改了，即可避免更新丢失。

**乐观锁**不是数据库层面上的锁，需要用户手动去加的锁。一般我们在数据库表中添加一个版本字段version来实现，例如操作1和操作2在更新User表的时，执行语句如下：

```mysql
update A set Name=lisi,version=version+1 where ID=#{id} and version=#{version}，
```



### 间隙锁

当我们用范围条件检索数据而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合范围条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在 的记录，叫做“间隙（GAP)”。**InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁**。



## 隔离

**几种情况**：

- **脏读**：一个事务读取到另外一个事务未提交的数据。
- **不可重复读**：一个事务读取到另外一个事务已经提交的数据，也就是说一个事务可以看到其他事务所做的修改。
- **幻读**：是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。和不可重复读类似，但虚读(幻读)会读到其他事务的插入的数据，导致前后读取不 一致，幻读的重点在于新增或者删除(数据条数变化)，不可重复读的重点是修改。

**隔离级别**：

- **读未提交，Read uncommitted**：会出现脏读，不可重复读，幻读
- **读已提交，Read committed**：会出现不可重复读，幻读
- **可重复读，Repeatable read**：会出现幻读(Mysql默认的隔离级别，但是Repeatable read配合gap锁不会出现幻读！)
- **串行化，Serializable**：串行，避免以上的情况



## 总结

表锁何时加：

- 在MyISAM存储引擎中，当执行SQL语句的时候是自动加的。
- 在InnoDB存储引擎中，如果没有使用索引，表锁也是自动加的。

现在我们大多数使用MySQL都是使用InnoDB，InnoDB支持行锁：

- 共享锁->读锁->S锁
- 排它锁->写锁->X锁

在默认的情况下，select是不加任何行锁的,事务可以通过以下语句显示给记录集加共享锁或排他锁。

- 共享锁（S）：

- ```mysql
  SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE
  ```

- 排他锁（X)：

- ```mysql
  SELECT * FROM table_name WHERE ... FOR UPDATE
  ```

- InnoDB基于行锁还实现了MVCC多版本并发控制，MVCC在隔离级别下的Read committed和Repeatable read下工作。MVCC实现了读写不阻塞。